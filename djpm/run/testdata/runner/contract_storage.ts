// generated by abi.json

import { Protobuf } from 'as-proto/assembly';
import { Context, Pair, Abi } from "./lib/index";


/*
export class Pair<T> {
    constructor(
        account: string,
        change: T,
    ) {
        this.account = account;
        this.change = change;
    }
    account: string;
    change: T;
}
*/

/*
call like:
        let dummy2 = new ContractXX.dummy2("0xdddd")
        let before = dummy2.before()
        let changes = dummy2.changes()

        let len = changes.length;
        let account = changes[0].account;
        let value = changes[0].change
*/

export namespace Storage {
    export class number {
        public before(): i32 {
            let changes = Context.getStateChanges(this.addr, "Storage.number", "");
            if (changes.all.length == 0) {
                // return a particular value, to tell aspect that value not found.
                return 0;
            }
            // we need to decode value to int.
            let value = changes.all[0].value;
            return Abi.asInt32(value);
        }

        public changes(): Array<Pair<i32>> {
            let changes = Context.getStateChanges(this.addr, "Storage.number", "");
            if (changes.all.length < 2) {
                // return a particular value, to tell aspect that value not found.
                return new Array<Pair<i32>>(0);
            }

            let res = new Array<Pair<i32>>(changes.all.length - 1);
            for (let i: i32 = 1; i < changes.all.length; i++) {
                // parsedValue pased from changes.all[i].value
                let parsedValue = Abi.asInt32(changes.all[i].value);
                res[i - 1] = new Pair(changes.all[i].account, parsedValue)
            }
            return res;
        }

        public lastest(): i32 {
            let changes = Context.getStateChanges(this.addr, "Storage.number", "");
            if (changes.all.length == 0) {
                // return a particular value, to tell aspect that value not found.
                return 0;
            }
            // we need to decode value to int.
            let value = changes.all[changes.all.length - 1].value;
            return Abi.asInt32(value);
        }

        public diff(): i32 {
            let changes = Context.getStateChanges(this.addr, "Storage.number", "");
            if (changes.all.length < 2) {
                // return a particular value, to tell aspect that diff is not valid.
                return 0;
            }

            let before = Abi.asInt32(changes.all.values[0]);
            let end = Abi.asInt32(changes.all.values[changes.all.length - 1]);;
            return end - before;
        }

        addr: string

        constructor(addr: string) {
            this.addr = addr;
        }
    }
}



// dummy1: Int
// dummy2: string
// dummy3: Map<int, XXStruct>
// dummy4: XXStruct


// list[] = changes()

// }


// dummy1: {
//     [
//         {
//             account: 00000000
//         value: xxx
//         },

//         {
//             account: xxx
//         value: xxx
//         },

//         {
//             account: xxx
//             value: xxx
//         },
//     ]

// }

