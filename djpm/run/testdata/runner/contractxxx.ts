// generated by abi.json

import { Protobuf } from 'as-proto/assembly';
import { Context, Pair } from "./lib/index";


/*
export class Pair<T> {
    constructor(
        account: string,
        change: T,
    ) {
        this.account = account;
        this.change = change;
    }
    account: string;
    change: T;
}
*/

/*
call like:
        let dummy2 = new ContractXX.dummy2("0xdddd")
        let before = dummy2.before()
        let changes = dummy2.changes()

        let len = changes.length;
        let account = changes[0].account;
        let value = changes[0].change
*/

export namespace ContractXX {
    export class dummy1 {
        constructor(addr: string) {
            this.addr = addr;
        }

        public before(): i32 {
            let changes = Context.getStateChanges(this.addr, "dummy1", "");
            if (changes.all.length == 0) {
                // return a particular value, to tell aspect that value not found.
                return -1;
            }
            // we need to decode value to int.
            let value = changes.all[0].value;
            // TODO call host api and decode the value
            // set value to ret
            let ret = 100;
            return ret;
        }

        public changes(): Array<Pair<i32>> {
            let changes = Context.getStateChanges(this.addr, "dummy1", "");
            if (changes.all.length < 2) {
                // return a particular value, to tell aspect that value not found.
                return new Array<Pair<i32>>(0);
            }

            let res = new Array<Pair<i32>>(changes.all.length - 1);
            for (let i: i32 = 1; i < changes.all.length; i++) {
                // parsedValue pased from changes.all[i].value
                let parsedValue = 0;
                res[i - 1] = new Pair(changes.all[i].account, 0)
            }
            return res;
        }
        public lastest(): i32 {
            let changes = Context.getStateChanges(this.addr, "dummy1", "");
            if (changes.all.length == 0) {
                // return a particular value, to tell aspect that value not found.
                return -1;
            }
            // we need to decode value to int.
            let value = changes.all.values[changes.all.length - 1];
            // TODO call host api and decode the value
            // set value to ret
            let ret = 300;
            return ret;
        }
        public diff(): i32 {
            let changes = Context.getStateChanges(this.addr, "dummy1", "");
            if (changes.all.length < 2) {
                // return a particular value, to tell aspect that diff is not valid.
                return -1;
            }

            // TODO decode the changes.all.values[0]
            let before = 100;
            // TODO decode the changes.all.values[changes.all.length - 1]
            let end = 300;
            return end - before;
        }

        // data: Array<Trace.Pairs<int>>;
        addr: string

    }
}



// dummy1: Int
// dummy2: string
// dummy3: Map<int, XXStruct>
// dummy4: XXStruct


// list[] = changes()

// }


// dummy1: {
//     [
//         {
//             account: 00000000
//         value: xxx
//         },

//         {
//             account: xxx
//         value: xxx
//         },

//         {
//             account: xxx
//             value: xxx
//         },
//     ]

// }

